=Структура модуля=
Как правило модуль состоит из:
# '''Сущность''' (не обязательный компонент) - класс,  представляющий некоторое понятие  предметной области в системе;
# '''Контроллер модуля''' (обязательный компонент для конкретных модулей) - класс,  ответственный за предоставление  интерфейса конкретного модуля экранам и другим модулям посредством делегирования обязанностей другим элементам модуля;
# '''Внутренний инсталлятор''' (не обязательный компонент) - класс, ответственный за настройку системы при установке и удалении модуля;
# '''Файл состояния''' (обязательный компонент) - файл state.ini, содержащий информацию о текущем состоянии модуля;
# '''Дополнительные компоненты'''  (не обязательный компонент) –  различные вспомогательные  компоненты, такие как файлы локализации, конфигурации модуля и др.

Ниже приведена схема возможной структуры модуля:

img: Module.png

В качестве примера рассмотрим модуль Console. Данный модуль содержит следующие компоненты:
* Контроллер модуля располагается в файле Controller.php. Данный компонент обязателен, так как модуль является конкретным;
* Файл состояния модуля state.ini, содержащийся во всех модулях;
* Каталог unit-тестов модуля test, являющийся дополнительным компонентом модуля, упрощающем его тестирование.

==Сущности==
Сущностью называется персистентный класс (подкласс класса LongObject), ответственный за хранение состояния модуля и представляющий некоторый объект предметной области. Так, для модуля TapeNews (лента новостей), необходимо хранить информацию о каждой конкретной новости, добавленной пользователем, для этих целей необходим персистентный объект, такой как Message, реализация которого приведена ниже:

 /**
  * $ORM\Table TapeNews_Message
  * $ORM\PK OID
  */
 class Message extends LongObject implements JsonSerializable{
   /**
    * @var string Заголовок новости.
    * $ORM\ColumnName title
    */
   private $title;

   /**
    * @var string Текст новости.
    * $ORM\ColumnName content
    */
   private $content;

   /**
    * @var integer Дата публикации новости.
    * $ORM\ColumnName dateCreate
    */
   private $dateCreate;

   ... // Методы сущности.
 }

Как видно, сущность это персистентный класс, содержащий относящиеся к данной сущности свойства. Часто сущности содержат методы, изменяющие состояние модуля, но иногда эти модули выносятся в менеджеры или контроллер. Количество сущностей в модуле не ограничивается одной, так, существуют модули с несколькими десятками сущностей, представляющими различные объекты сложной предметной области, но такие модули встречаются редко, как правило модуль содержит от одной до трех сущностей.

==Контроллер==
Контроллер это особый класс (подкласс класса ModuleController), используемый для взаимодействия с модулем. Данный класс присутствует только в конкретных модулях (так как виртуальные модули не должны иметь интерфейса доступа) и реализует открытый интерфейс взаимодействия с модулем, к которому он относится. Все public методы контроллера могут быть вызваны из других (зависимых) модулей или экранов (если это допускается правилами доступа), при этом возвращаемые этим методом данные будут переданы вызывающему модулю. Как правило контроллер содержит часть бизнес-логики модуля, другая часть содержится в сущностях модуля как было сказано ранее.

Интерфейс контроллера должен быть разработан так, чтобы использующий его объект (зависимый модуль, экран или программист) мог полноценно управлять модулем. Так, если модуль TapeNews не содержит метода, отвечающего за удаление новостей, то такой интерфейс контроллера нельзя считать завершенным, так как использующий его объект не имеет всех необходимых для управления модулем методов. Завершенный интерфейс обычно содержит следующие методы:
* Добавление, удаление, изменение и получение всех сущностей модуля;
* Методы, решающие все поставленные перед модулем задачи.

Так как контроллер модуля является дочерним классом класса ModuleController, он включает два специальных метода: afterRun и beforeRun - которые вызываются до и после обращения к модулю соответственно. Эти методы могут применятся для подготовки модуля к использованию и не могут быть вызваны пользователем, не смотря на то, что являются public.

==Внутренний инсталлятор==
В связи с тем, что многие модули содержат сущности, состояния которых необходимо хранить в базе данных, необходим специальных механизм, позволяющий добавлять необходимые таблицы в используемую базу данных при установке модуля в систему, а так же удалять их при удалении модуля. Эти задачи решает класс Installer (подкласс класса ModuleInstaller) модуля. Данный класс включает методы: install, upgrade и uninstall - вызываемые при установке, обновлении и удалении модуля соответственно.

Внутренний инсталлятор используется не только для изменения базы данных при установке и удалении модуля, но и для создания некоторых сущностей. Так, модуль Access (роли доступа) при установке создает несколько ролей доступа, используемых многими модулями системы, а так суперпользователя.

Ниже приведен пример внутреннего инсталлятора модуля TapeNews:
 class Installer extends ModuleInstaller{
   public function install(){
     $DDO = DDOFabric::getInstance();
     $DDO->query('CREATE TABLE `TapeNews_Message` (`OID` VARCHAR(36) NOT NULL PRIMARY KEY,`title` VARCHAR(30) NOT NULL,`content` VARCHAR(1000) NOT NULL,`dateCreate` INTEGER NOT NULL) DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci');
   }

   public function uninstall(){
     $DDO = DDOFabric::getInstance();
     $DDO->query('DROP TABLE `TapeNews_Message`');
   }
 }

==Файл состояния==
Файл состояния (state.ini) содержится во всех установленных модулях и хранит информацию о модуле, такую как:
* Component::name - имя модуля. Имя модуля может состоять только из латинских букв и знаков подчеркивания (но не в качестве первого символа) в нотации UpperCamelCase;
* Component::version - версия модуля. Значение данного свойства должно соответствовать маске: [0-9]{1,}\.[0-9]{1} - то есть мажорная версия модуля может иметь множество разрядов, а минорная не более одного разряда;
* Component::type - тип модуля (виртуальный - virtual; конкретный - specific);
* Component::platformVersion - допустимые для работы модуля версии платформы. Значение данного свойства имеет вид: начальная версия-конечная версия. Если выполняется upgrade платформы до версии, не соответствующей данному показателю, то модуль работать не будет;
* Depending::parent - имя родительского модуля, и его допустимые версии. Значение данного свойства имеет вид: начальная версия-конечная версия;
* Depending::used - имена используемых модулей, и их допустимые версии. Значение данного свойства имеет вид: имя модуля:начальная версия-конечная версия, ...;
* Depending::children - имена дочерних модулей перечисленные через запятую;
* Depending::destitute - имена зависимых модулей перечисленные через запятую;
* Access - список прав доступа к методам контроллера модуля.

Ниже приведен пример файла состояния модуля SystemPackages:
 [Component]
 name=SystemPackages
 version=4.0
 type=specific
 platformVersion=2.0.0-2.0.0 # Модуль может работать только на платформе версии 2.0.0
 [Depending]
 used=MockModule:0.1-1.0 # Модуль использует MockModule версии от 0.1 до 1.0 включительно
 destitute=MockModule # От данного модуля зависит модуль MockModule
 parent=
 children=Console,InstallerModules,InstallerScreens # Для данного модуля имеются следующие дочерние модули
 [Access] # Модуль не имеет прав доступа, так как является виртуальным

Файл состояния создается автоматически при установке модуля и изменяется системой. Благодаря этому файлу возможно следить за зависимостями модулей системы и разрешать некоторые конфликтные ситуации.

==Дополнительные компоненты==
Часто для работы модуля нужны дополнительные компоненты, такие как файлы данных, документация, unit-тесты и т.д. Все эти компоненты относятся к дополнительным компонентам модуля и не стандартизируются, но некоторые из них присутствуют во всех "хороших" модулях, это:
* Каталог документации - каталог man, содержащий файлы документации модуля на различных языках. При этом каждый файл называется согласно имени языка, на пример для русской документации используется файл с именем ru, а для английской - en;
* Каталог unit-тестов - каталог test, содержащий класс unit-тестов компонентов модуля.

=Хранилище модулей=
Каталог D/model/modules является хранилищем модулей. Этот каталог используется для размещения устанавливаемых в систему модулей и их компонентов согласно следующим правилам:
* Все компоненты одного модуля размещаются в каталоге, имя которого соответствует имени модуля;
* Каталог дочернего модуля размещается в каталоге родительского модуля.

Согласно указанным правилам, модуль Console, должен размещаться в каталоге D/model/modules/SystemPackages/Console, так как является дочерним по отношению к содулю SystemPackages. Так же следует помнить, что все каталоги, являющиеся дополнительными компонентами модуля должны начинаться со строчной буквы, это предотвратит конфликт имен в будущем, так как все имена модулей начинаются с заглавной буквы.

=Установка модуля=
Учитывая все вышесказанное, для установки модуля в систему достаточно:
# Создать каталог модуля в хранилище модулей следуя оговоренным правилам;
# Создать файл состояния модуля правильной структуры;
# Выполнить метод install внутреннего инсталлятора модуля;
# Зарегистрировать модуль в роутере модулей.

После выполнения данных действий модуль готов к использованию.