=Терминология=
* Фабрика - класс, ответственный за создание сложных объектов;
* Фабрика объектной SQL инструкции - фабрика, ответственная за создание одной из объектных SQL инструкций (Select, Update, Insert или Delete).

=Польза от использования фабрики=
Процесс создания объектной SQL инструкции достаточно сложен из-за большого числа компонентов. Для решения этой проблемы может быть использован данный пакет, включающий несколько фабрик объектных SQL инструкций, таких как:
* Select - фабрика служит для создания объектной SQL инструкции Select;
* Update - фабрика служит для создания объектной SQL инструкции Update;
* Insert - фабрика служит для создания объектной SQL инструкции Insert;
* Delete - фабрика служит для создания объектной SQL инструкции Delete;
* Where - фабрика служит для создания объектного SQL компонента Where.

Все эти фабрики упрощают процесс конструирования объектных SQL инструкций путем использования упрощенного, объектного интерфейса и "цепных методов".

=Select=
Фабрика Select позволяет создавать объектную SQL инструкцию Select со всеми допустимыми для этой инструкции компонентами.

Приведем пример создания простой объектной SQL инструкции Select с использованием фабрики:

 $select = Select::getInstance()->fields()->tables(['people'])->get(); // Результатом является объектная SQL инструкция Select
 echo $select->interpretation('mysql); // SELECT * FROM people

Как видно, для создания объектной SQL инструкции используется объект класса Select, который может быть получен через вызов метода getInstance, как и все остальные фабрики. Данный объект включает множество методов, вызов которых конструирует результирующую инструкцию определенным образом. Обратите внимание на способ вызова методов объекта, так как практически все методы возвращают ссылку на фабрику, возможен удобный "цепной вызов методов".

Для возврата из фабрики полученной в результате ее работы инструкции, используется метод get.

Приведем пример создания более сложной объектно SQL инструкции Select с использованием фабрики:

 $select = Select::getInstance()->fields(['OID', 'people.name'])->tables(['people'])->orderBy(['name'])->where('OID', '>', '10')->select->get();
 echo $select->interpretation('mysql); // SELECT OID,people.name FROM people ORDER BY name ASC WHERE (OID > "10")

Интерфейс взаимодействия с фабрикой несколько изменяется после вызова метода where, который определяет логическое выражение инструкции, это связано с особенностью реализации фабрики Where и будет рассмотрено далее.

=Update=
Фабрика Update позволяет создавать объектную SQL инструкцию Update со всеми допустимыми для этой инструкции компонентами.

Приведем пример создания объектной SQL инструкции Update с использованием фабрики:

 $update = Update::getInstance()->table('people')->data(['name' => 'nikolay'])->where('OID', '=', '1')->update->get(); // Результатом является объектная SQL инструкция Update
 echo $update->interpretation('mysql); // UPDATE people SET name = "nikolay" WHERE (OID = "1")

Если один из элементов массива, передаваемого в метод data будет иметь значение null, то он определит параметризованное значение:

 $update = Update::getInstance()->table('people')->data(['name' => null])->where('OID', '=', '1')->update->get();
 echo $update->interpretation('mysql); // UPDATE people SET name = ? WHERE (OID = "1")

=Insert=
Фабрика Insert позволяет создавать объектную SQL инструкцию Insert со всеми допустимыми для этой инструкции компонентами, кроме возможности определения вложенного Select запроса.

Приведем пример создания объектной SQL инструкции Insert с использованием фабрики:

 $insert = Insert::getInstance()->table('people')->data(['phone' => '00001', 'name' => 'nikolay'])->get(); // Результатом является объектная SQL инструкция Insert
 echo insert->interpretation('mysql); // INSERT INTO people (phone, name) VALUES ("00001", "nikolay")

Если один из элементов массива, передаваемого в метод data будет иметь значение null, то он определит параметризованное значение (см. Update).

=Delete=
Фабрика Delete позволяет создавать объектную SQL инструкцию Delete со всеми допустимыми для этой инструкции компонентами.

Приведем пример создания объектной SQL инструкции Delete с использованием фабрики:

 $delete = Delete::getInstance()->table('people')->where('OID', '<', '10')->delete->get(); // Результатом является объектная SQL инструкция Delete
 echo $delete->interpretation('mysql); // DELETE FROM people WHERE (OID < "10")

=Where=
Фабрика Where отличается от рассмотренных ранее фабрик тем, что позволяет создавать объектный SQL компонент, а не инструкцию. Это связано с тем, что компонент Where достаточно сложная, иерархическая конструкция с вложенными выражениями и приоритетом операций.

Те фабрики (Select, Update, Delete), которые имеют метод where, конструируют инструкцию с помощью фабрики Where. Метод where возвращает объект фабрики Where, который отвечает за создание логического выражения для инструкции, при этом объект дополняется специальным свойством, имя которого соответствует имени инструкции (select, update, delete), которое ссылается на используемую фабрику для возврата к ней.

Рассмотрим пример использования Where фабрики:

 $delete = Delete::getInstance()->table('people')->where('name', '=', 'ivan')->create('OID', '<', '5')->orC('OID', '>', '10')->last('AND')->delete->get(); // DELETE FROM people WHERE ((name = "ivan") AND ((OID < "5") OR (OID > "10")))

На схеме ниже изображен процесс работы фабрик Delete и Where:

[[File:whereBuilder.png]]

Как можно заметить, сначала используется фабрика Delete, но после вызова метода where, возвращается фабрика Where, которая используется для формирования сложного логического выражения. Свойство delete этой фабрики ссылается на используемую ранее фабрику Delete, что позволяет вернуться к этой фабрике, а метод get объединяет результат работы фабрик Delete и Where в одну инструкцию.

Фабрика where позволяет формировать логическое выражение с помощью методов andC и orC, которые добавляют справа к текущему логическому выражению логическую операцию с оператором И или ИЛИ соответственно. Данные методы позволяет создавать логические выражения, в которых приоритет снижается по мере продвижения к концу этого выражения. Приведем пример:

 echo Where::getInstace()->create('OID', '>', '0')->orC('OID', '<', '10')->andC('name', '=', 'ivan')->last()->interpretation('mysql'); // WHERE ((OID > "0") OR (OID < "10")) AND (name = "ivan");

Очевидно, что этот механизм не позволяет определять порядок выполнения логической инструкции. На пример нельзя создать выражение вида: ((...) OR (...)) AND ((...) OR (...)) - с использованием только методов andC и orC. Но это возможно благодаря методам create и last.

Метод create создает вложенное логическое выражение, которое формируется так же, как и первое выражение в фабрике, но с той лишь разницей, что до вызова метода last оно не соединено с основным логическим выражением. Это новое логическое выражение помещается в стек и соединяется с предыдущим тогда, когда вызывается метод last с указанием логического оператора, объединяющего эти два выражения. Рассмотрим пример:

 echo Where::getInstace()->create('OID', '>', '0')->orC('OID', '<', '10')->create('name', '=', 'ivan')->orC('name', '=', 'petr')->last('AND')->last()->interpretation('mysql'); // WHERE ((OID > "0") OR (OID < "10")) AND ((name = "ivan") OR (name = "petr"));

Следует так же обратить внимание на завершающий вызов метода last без параметров, он возвращает сформированное фабрикой логическое выражение (подобно методу get у фабрик инструкций). Данный метод можно не вызывать при использовании фабрик Select, Update, Insert и Delete, так как он автоматически вызывается при вызове у этих фабрик метода get.
