=Терминология=
* Сокет - интерфейс взаимодействия двух процессов между собой. По средствам сокетного соединение возможен обмен данными между процессами;
* Клиент-сокет - сокет, используемый процессом для подключение к сервер-сокету с целью получения или передачи ему данных;
* Подключение - процесс взаимодействия клиент-сокета с сервер-сокетом с целью создания и предоставления двунаправленного потока ввода/вывода клиенскому процессу;
* Сервер-сокет - сокет, ожидающий подключение клиент-сокета к определенному порту адреса с целью получения или передачи ему данных;
* Прослушивание порта - подключение сервер-сокета к порту и ожидание запроса клиента.

=Двойственность сокетов=
Любой сокет может стать либо клиент-сокетом, либо сервер-сокетом, в зависимости от того, будет ли он подключаться или прослушивать порт соответственно. Объекты класса Socket, данного пакета, реализованы с учетом этой двойственной природы любого сокета, то есть каждый объект может быть либо клиент, либо сервер-сокетом.

Рассмотрим пример создания клиент-сокета:

 $sc = new Socket; // Создание сокета. Объект пока не будет являться клиентом или сервером.
 $stream = $sc->connect('127.0.0.1', 1024); // Использование сокета как клиента. Метод возвращает поток ввода/вывода.
 // С этой строчки $sc снова станет неопределенным сокетом и может быть использован как клиент или сервер.

Так же рассмотрим пример создания сервер-сокета:

 $sl = new Socket; // Создание сокета. Объект пока не будет являться клиентом или сервером.
 $sl->listen('127.0.0.1', 1024); // Прослушивание порта 1024.
 $stream = $sl->accept(); // Проверка наличия клиентского соединения на прослушиваемом порту.
 $sl->shutdown(); // Отключение сокета.
 // С этой строчки $sl снова станет неопределенным сокетом и может быть использован как клиент или сервер.

Чтобы убедиться в двойтвенности объектов класса Socket, используем один объект как клиент и сервер одновременно:

 $s = new Socket;
 $s->listen('127.0.0.1', 1024); // Сейчас $s является сервер-сокетом.
 $s->shutdown();
 $s->connect('127.0.0.1', 1024); // А сейчас клиент-сокетом.
 $s->listen('127.0.0.1', 1024); // Сейчас снова сервер-сокетом.

Можно заметить, что использовать один объект Socket для прослушивания и одновременного коннекта невозможно, так как в момент прослушивания порта объект блокируется до вызова метода shutdown, который, в свою очередь, делает сокет двойственным.

=Работа с потоками=
Методы connect клиент-сокета и accept сервер-сокета возвращают созданные потоки ввода/вывода между двумя сокетами. Если Socket используется для установки соединения, то Stream для обмена данными между соединенными процессами.

Ниже приведен пример использования класса Stream:

 $sl = new Socket;
 $sl->listen('127.0.0.1', 1024); // Порт 1024 используется в качестве примера. На практике прослушивание данного порта доступно только суперпользователю.
 $sc = new Socket;
 $clientStream = $sc->connect('127.0.0.1', 1024); // Получение потока вводы/вывода на стороне клиента.
 $serverStream = $sl->accept(); // Получение потока вводы/вывода на стороне сервера.
 $clientStream->write('Hello!'); // Передача данных клиентом в поток.
 echo $serverStream->readAll(); // Hello! - Чтение данных сервером из потока.
 $serverStream->write('Bye!'); // Передача данных сервером в поток.
 echo $clientStream->readPackage(4); // Bye! - Чтение данных клиентом из потока.
 $sl->shutdown();

Как видно, для обмена данными используются два потока ввода/вывода по одному на каждом "конце" потока (на стороне сервера и клиента). Данные, записываемые клиентом в поток, передаются серверу и наоборот.

Следует учитывать особенности определения окончания передачи при считывании данных из потока. Применяется два подхода:
* Фиксированная длина - все сообщения, передаваемые между клиентом и сервером имеют фиксированную, заранее определенную длину, при этом конец сообщения можно легко определить. Для работы с такими сообщениями используется метод readPackage, который блокирует выполнение программы до получения указанного числа байт;
* Таймаут запроса - для определения окончания передачи используется счетчик. Если в течении указанного времени очередного байта нет в потоке, значит передача завершена. Для работы с такими сообщениями используются методы read, readString, readLine и readAll.