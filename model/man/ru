=Архитектура слоя=
Прикладные задачи разрабатываемой с помощью системы решаются с использованием '''модулей''', расположенных в данном слое системы. Модуль представляет собой функционально завершенный пакет классов, решающих строго определенный границами модуля круг задач. Элементы слоя домена активно используют элементы слоев служб и инструментов, что делает их зависимыми от семантики данных слоев.
Модульность слоя домена включает следующие основные принципы:
* '''Инкапсуляция''' – по средствам сокрытия для зависимых модулей внутренней организации используемого модуля за открытым интерфейсом его контроллера;
* '''Наследование''' – по средствам механизма наследования модулей;
* '''Полиморфизм''' - по средствам замены одного модуля другим при условии, что семантика их контроллеров идентична.

=Зависимости=
Модули ('''зависимые модули''') могут использовать другие установленные в системе модули ('''используемые модули''') по средствам взаимодействия с их контроллером. Такой механизм называется взаимодействием модулей и представлен на следующей схеме:
img: Interaction.png
Как видно из схемы, зависимый модуль может вызывать методы контроллера используемого модуля. Так же зависимому модулю известны все сущности используемого модуля, что позволяет ему использовать их для определения типа возвращаемого значения, их констант и тому подобного, но не позволяет обращаться к ним с целью вызова методов или получения значений свойств. Сказанное можно видеть в листинге метода getRolesUser контроллера модуля Access:
 public function getRolesUser(GUID4 $userOID = null){
   ...
   if($user instanceof DefaultUser){ // Определение класса DefaultUser используемого модуля Users.
     ...
   }
   else{
     ...
   }
   ...
 }

=Наследование=
Модуль ('''дочерний модуль''') может наследовать и расширять функциональные возможности другого модуля ('''родительского модуля'''), что может создавать иерархию наследования модулей. Модель наследования модулей изображена на следующей схеме:
img: Inheritance.png
Как видно из рисунка, сущности дочернего модуля могут наследовать реализацию сущностей родительского модуля, а так же модуль может иметь дополнительные сущности, доступные только данному модулю. Менеджеры дочернего модуля могут напрямую вызывать (делегировать полномочия) менеджеры родительского модуля, а так же наследовать их реализацию (то же касается контроллера).

=Виртуализация=
Модуль, доступ к которому может быть получен из слоев представления и домена, называется '''конкретным модулем''', такой модуль имеет контроллер, по средствам которого и осуществляется доступ к нему. В противоположность конкретным модулям, доступ к '''виртуальным модулям''' могут получить только их дочерние модули, но не с использованием контроллера (виртуальный модуль не имеет контроллера), а с использованием прямых ассоциаций с его классами. Чаще всего виртуальные модули используются для вынесения общей логики.

=Правила модульности системы=
Основными правилами системы относительно модульности слоя домена являются:
# Создание прямых ассоциаций между классами двух модулей разрешается только дочерним модулям по отношению к их прямым или косвенным родителям. Классы одного модуля не должны «знать» о существовании классов другого модуля (если первый модуль не является потомком второго). Передача команды модулю должна осуществляться только по средствам его контроллера, а доступ к контроллеру должен осуществляться только по запросу к центральному контроллеру;
# Каждый конкретный модуль должен включать в себя класс, выполняющий роль контроллера. Данный класс должен решать задачи взаимодействия с модулем из других частей системы. Отсюда следует, что любая часть системы (за исключением слоев служб и инструментов, которые вообще не имеют доступ к слою домена) должна взаимодействовать с модулями только через их контроллеры. Виртуальные модули не должны иметь контроллера, это связано с тем, что использование виртуальных модулей невозможно;
# Классы одного модуля должны решать только строго ограниченный самим модулем круг задач. На пример, если модуль служит для реализации «Новостной ленты сайта», то все классы должны способствовать решению данной задачи, но не решению других, смежных задач. Более того, для предотвращения «раздувания» модуля, каждый модуль должен решать небольшой круг взаимосвязанных задач;
# Модули не должны зависеть от способа их визуализации и инструментов взаимодействия с ними. Здесь речь идет об интерфейсе пользователя, используемом для управления модулем. Реализация модуля должна быть такой, чтобы замена интерфейса, или создание дополнительных экранов, не требовали изменения реализации модуля. Именно пользовательский интерфейс должен стыковаться с модулем, а не наоборот. С другой стороны модуль должен быть реализован по возможности так, чтобы реализация его интерфейса была наименее зависима от интерфейса его контроллера. Это может быть достигнуто путем стандартизации интерфейса контроллера.

=Центральный контроллер=
Для расширения функциональности системы за счет модулей, необходим механизм, позволяющий экранам системы взаимодействовать с ними. Данным механизмом является  CentralController. Этот объект позволяет обращаться к методам контроллеров модулей и передавать данные, полученные от них, слою представления. Все GET и POST запросы, передаваемые от экранов должны обрабатываться именно данным объектом, так как он не только определяет и выполняет целевой метод, но и отвечает за верификацию входных данных, контроль доступа и обработку ошибок.

Для вызова метода модуля по средствам GET или POST запроса необходимо передать CentralController следующие переменные:
* module - имя целевого модуля;
* action - имя вызываемого метода модуля;
* params - массив параметров, передаваемых вызываемому методу в виде JSON строки.

Процесс обработки GET или POST запроса центральным контроллером имеет следующий вид:
# Получение и преобразование переменных module, action и params;
# Верификация параметров в соответствии с требованиями целевого метода;
# Нахождение целевого модуля и получение его контроллера;
# Проверка прав доступа пользователя к целевому методу;
# Выполнение метода afterRun контроллера;
# Выполнение целевого метода и получение возвращенных им данных;
# Выполнение метода beforeRun контроллера;
# Возврат полученных от целевого метода данных в качестве ответа сервера.

Все данные, возвращаемые целевым методом с помощью операции return передаются в теле ответа сервера в виде JSON строки. Другими словами, если целевой метод вернет массив данных, то этот массив будет сериализован согласно формату JSON и передан в теле ответа сервера.

Ниже приведен пример вызова метода модуля с помощью GET запроса клиента к центральному контроллеру:

 http://localhost/D/model/CentralController.php?module=Console&action=test

В данном примере выполняется вызов метода test модуля Console.

Важной особенностью центрального контроллера является то, что его методы могут быть вызваны не только GET или POST запросом, но и программно, при этом в случае отсутствия данных в переменных module, action, объект будет вести себя как обычный Singleton, с помощью которого можно вызывать методы модулей.

Как было сказано ранее, центральный контроллер так же отвечает за обработку ошибок. Так, если любая часть системы или модуль выбросит исключение, которое не будет обработано в системе, то оно дойдет до центрального контроллера, который, в свою очередь запишит информацию в журнал и передаст объект исключения в виде JSON строки в теле ответа сервера, при этом код ответа будет установлен в 500.

Верификация данных, передаваемых в качестве параметров целевого метода выполняется за счет использования оберток (D\library\patterns\entity\dataType), которыми типизируют аргументы методов контроллера модуля:
 class Controller extends ModuleController{
   private function getAbsoluteAddress(FileSystemAddress $packageAddress){
     ...
   }
   ...
 }

В данном примере представлен метод, аргумент коготоро типизирован классом FileSystemAddress. Перед вызовом этого метода, центральный контроллер постарается привести параметр метода к типу FileSystemAddress с помощью вызова его метода reestablish, который, в свою очередь, обеспечит верификацию. Таким образом, центральный контроллер может защитить от "плохих" данных в случае правильной расстановки типизации аргументов методов модулей.

Для контроля доступа пользователя к методу модуля центральный контроллер использует модуль Access. Если данный модуль не установлен в систему, центральный контроллер не выполняет проверки прав доступа, а разрешает доступ любому пользователю к любому модулю. Это может быть очень опасным, потому обязательно устанавливайте и настраивайте модуль Access в систему сразу после ее установки.