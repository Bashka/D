=Терминология=
* Пользователь - программный компонент, обращающийся к ресурсу с целью получения от него данных;
* Ресурс - программный компонент, предоставляющий требуемые пользователю данные;
* Данные - информация любого доступного (для языка PHP) типа, однозначно идентифицируемая по средствам строки-идентификатора;
* Идентификатор данных - строка, однозначно идентифицирующая данные;
* Кэш - программный компонент, обеспечивающий хранение часто используемых данных на время исполнения скрипта для увеличения скорости доступа к ним;
* Ограниченный кэш - кэш, число хранимых данных в котором ограничено некоторой конечно велечиной (объем кэша). При добавлении новых данных в такой кэш, устаревшие данные удаляются из него по правилу "очереди";
* Устаревшие данные - данные, добавленные в кэш первыми в момент добавления новых данных в заполненный, ограниченный кэш;
* Неограниченный кэш - кэш, число хранимых данных в котором не ограничено;
* Плотность кэша - число хранящихся в кэше данных;
* Отчистка кэша - процесс удаление данных, хранящихся в кэше.

=Польза простого кэша=
Механизм кэширования часто применяется для повышения скорости доступа к данным за счет хранения их в кэше. Простой кэш, реализованный в данном пакете, позволяет сохранять данные только на период исполнения скрипта, после чего данные удаляются. Это можно использовать для доступа к повторно запрашиваемой информации, на пример строкам файла или сложным объектам.

Для упрощения доступа к данным простой кэш, реализованный в данном пакете, использует текстовый идентификатор и целевой ресурс кэша. В качестве идентификатора может использоваться любая строка, однозначно идентифицирующая данные, на пример номер стоки в файле, или имя объекта, или идентификатор записи в базе данных. В случае, если полученные данные необходимо еще и дополнить информацией из кэша, на пример ссылками на объекты, примеряется дополнительный параметр. В качестве целевого ресурса кэша может быть использован любой объект или другой тип данных. Встречаются так же кэши-фабрики - это кэши, которые не используют целевой ресурс для запроса данных, а сами создают объекты в зависимости от идентификатора данных и кэшируют их.

Особенностью любого кэша является его объем, то есть количество данных, которые может хранить в себе кэш. В случае переполнения кэша, старые данные должны заменяться на новые. Это позволяет своевременно удалять устаревшие данные их кэша и исключить переполнение памяти ненужными данными. Реализованный в данном пакете простой кэш позволяет не только следить за своевременым удалением устаревших данных, но и динамически изменять природу их хранения, становясь как неограниченным, так и не кэширующим.

= Способ реализации=
В качестве примера создадим два кэша, первый для кэширования строк файла, второй для кэширования создаваемых объектов. Для этого необходимо конкретизировать класс Cache данного пакета и реализовать в дочернем классе метод getFromSource, который должен запрашивать данные из ресурса и возвращать их. Заметьте, что метод объявлен как protected, то есть вызов этого метода выполняется не программистом, а самим классом Cache, в частности его методом getData, который является "шаблонным".

Кэширование выполняется автоматически методом getData согласно следующей схеме:

[[File:sequence.png]]

Как видно, при вызове метода getData кэш определяет, располагает ли он запрашиваемыми данными.Если данные в кэше имеются, то он возвращает их пользователю, иначе обращается к методу getFromSource. Метод getFromSource, в свою очередь, запрашивает данные у ресурса и возвращает их в кэш, после чего они кэшируются и возвращаются пользователю.

==Класический кэш==
Первый реализуемый здесь кэш, должен кэшировать данные, предоставляемые следующим классом:

 class File{
   /**
    * Метод считывает из файла и возвращает строку с указанным номером. Отсчет начинается от нуля.
    * @param integer $num Номер запрашиваемой строки.
    * @return string|null Запрошенная строка или null в случае, если указанной строки нет в файле.
    */
   public function readLine($num){
     ...
   }
 }

Для реализации подходящего кэша достаточно реализовать метод getFromSource, который будет принимать в качестве идентификатор данных номер запрашиваемой строки, а дополнительный аргумент arguments использоваться не будет:

 class FileCache extends Cache{
   protected function getFromSource($key, array $arguments = null){
     return $this->resource->readLine((integer) $key);
   }
 }

Создается данный кэш путем передачи ему объекта класса File в конструктор при инстанциации:
 $fc = new FileCache(20, new File('test.txt'));

Используется данный кэш путем вызова метода getData и передачей ему номера запрашиваемой строки. Метод возвращает запрашиваемую строку предварительно кэшируя ее. Теперь при повторном запросе этой строки данные будут возвращены из кэша:

 $data = $fc->getData(0);
 $data = $fc->getData(0); // Данные возвращаются из кэша.

==Кэш-фабрика и дополнение данных==
Второй класс отличается тем, что не использует целевой ресурс для запроса данных, а самостоятельно создает данные при запросе. Предположим что необходимо создавать объекты следующих классов при запросе из кэша:
 class OpenState{
   /**
    * @param object $context Контекст состояния.
    */
   public function __construct($context){
     // ...
   }
 }

 class CloseState{
   /**
    * @param object $context Контекст состояния.
    */
   public function __construct($context){
     // ...
   }
 }

Для кэширования создаваемых объектов, достаточно реализовать фабричный метод getFromSource. Ключом здесь будет выступать имя класса, а в качестве обязательного параметра конструктора создаваемого объекта, будут выступать данные параметра $arguments.

 class StateCache extends Cache{
   protected function getFromSource($key, array $arguments = null){
     return new $key($arguments);
   }
 }

Такой кэш позволяет создавать сложные объекты один раз за сессию, а при повторном обращении получать их из кэша. Обратите внимание, в данном примере параметр $arguments не используется для идентификации кэшируемых данных, а применяется для вызова конструктора объекта.
