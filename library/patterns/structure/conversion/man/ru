=Терминология=
* Интерпретация объекта - преобразование объекта в данные иного типа;
* Восстановление объекта - восстановление состояния объекта на основании объекта-основания;
* Объект-основание - объект (или данные другого типа), состояние которого используется в качестве основы для построения другого объекта;
* Строка-основание - строка, являющаяся объектом-основанием;
* Лексема - минимальный элемент строки;
* Шаблон верификации - регулярное выражение, которому должна соответствовать строка-основание, чтобы из нее возможно было восстановить объект. Данное регулярное выражение так же разбивает строку-основание на лексемы;
* Именованная лексема - компонент регулярного выражения, который может быть встроен в шаблон верификации.

=Виды преобразований и их семантика=
Часто требуется преобразовать данные одного типа в другой. Отсюда можно выделить следующие виды преобразований:
* Преобразование объекта в элементарные типы данных (интерпретация);
* Восстановление состояния объекта из элементарных типов данных (восстановление) или другого объекта (метаморфоза).

Данный пакет служит для определения семантики классов, реализующих любой из указанных видов преобразований:
* Metamorphosis - интерфейс, используемый теми классами, которые могут быть инстанциированы из объектов других классов;
* Interpreter - интерфейс, используемый теми классами, которые могут быть преобразованы в данные типа string;
* Restorable - интерфейс, используемый теми классами, объекты которых могут быть восстановлены из данных типа string.
* TRestorable - частичная реализация интерфейса Restorable.

==Метаморфоза==
Процесс создания объекта одного класса на основании объекта другого класса называется метаморфозом. Классы, позволяющие выполнять данное восстановление должны реализовать интерфейс Metamorphosis и в частности метод metamorphose, который должен выполнять инстанциацию объекта.

Метод metamorphose является статичным, так как служит для инстанциации объекта. Этот метод принимает в качестве первого аргумента объект-основание, а в качестве второго может принимать дополнительные входные данные, используемые для восстановления.

В качестве примера реализуем простой механизм метаморфоза. В качестве объекта-основания используем объект следующего класса:

 class File{
   private $name; // Имя файла

   private $address; // Адрес файла

   private $location; // Каталог, хранящий файл

   public function getName(){
     return $this->name;
   }

   public function getAddress(){
     return $this->address;
   }

   public function getLocation(){
     return $this->location;
   }

   public function __construct($location, $name){
     $this->name = $name;
     $this->location = $location;
     $this->address = $location . '\\' . $name;
   }
 }

Данный класс представляет файл в файловой системе. Этот класс очень упрощен в целях демонстрации и включает только такие свойства как имя и адрес файла.

Предположим нам необходимо создать на его основе объект класса Link, который будет представлять символическую ссылку на файл. Для этого достаточно реализовать интерфейс Metamorphosis:

 class Link implements Metamorphosis{
   private $addressFile; // Имя и адрес целевого файла

   private $location; // Каталог, хранящий ссылку

   private $name; // Имя ссылки

   public static function metamorphose($object, $driver = null){
     return new self('LinkTo_'.$object->getName(), $object->getLocation(), $object->getAddress());
   }

   public function __construct($name, $location, $addressFile){
     $this->addressFile = $addressFile;
     $this->location = $location;
     $this->name = $name;
   }
 }

Как видно из примера, объекты класса Link могут быть созданы (восстановлены) на основании объектов класса File, при этом имя ссылки будет состоять из префикса LinkTo_ и имени файла, а их родительский каталог будет соответствовать родительскому каталогу целевого файла.

==Интерпретация==
Процесс преобразования объекта в данные строкового типа называется интерпретацией. Классы, позволяющие выполнять данное преобразование должны реализовать интерфейс Interpreter и в частности метод interpretation, который должен выполнять преобразование объекта и возвращать строку, созданную на его основании.

Метод interpretation может принимать качестве первого аргумента дополнительные данные, которые могут быть использованы для формирования целевой строки.

Метод interpretation очень напоминает один из стандартных методов языка PHP - __toString - разница лишь в том, что он является частью интерфейса Interpreter, который свидетельствует о том, что объект может быть преобразован в строку.

В качестве примера добавим классу из предыдущей главы File возможность преобразования в строку, содержащую расположение и имя файла:

 class File implements Interpreter{
   ...

   public function interpretation($driver = null){
     return $this->getLocation().' '.$this->getName();
   }
 }

Обратите внимание на формат создаваемой методом interpretation строки. Она включает как имя, так и расположение файла, при чем оба этих значения разделены символом пробела.

==Восстановление==
Процесс преобразования данных строкового типа в объект называется восстановлением. Классы, позволяющие выполнять данное восстановление должны реализовать интерфейс Restorable и в частности методы isReestablish и  reestablish, которые должны проверять возможность восстановления и выполнять его соответственно.

Метод isReestablish принимает в качестве первого аргумента строку-основание и может принимать в качестве второго аргумента дополнительные данные, которые могут быть использованы для верификации.

Метод reestablish так же принимает в качестве первого аргумента строку-основание и может принимать в качестве второго аргумента дополнительные данные, которые могут быть использованы для восстановления.

Для того, чтобы наш предыдущий пример был закончен, добавим классу File возможность восстановления его объектов из строки, возвращаемой методом interpretation, для этого просто реализуем интерфейс Restorable:

 class File implements Interpreter, Restorable{
   ...

   public static function isReestablish($string, $driver = null){
     return preg_match('/^(\/[A-Za-z_]+)+ [A-Za-z_]+$/u', $string) == 1;
   }

   public static function reestablish($string, $driver = null){
     $tokens = explode(' ', $string);
     return new self($tokens[0], $tokens[1]);
   }
 }

Метод reestablish, в данном примере, позволяет восстанавливать объекты из адресов, имена каталогов и файлов в которых не содержат ничего, кроме латинских букв и символа _. Данное ограничение не является частью интерфейса, а сделано для упрощения примера.

Как видно, теперь объекты класса File могут создаваться на основании строк, возвращаемых методом interpretation. Это может использоваться для сохранения объектов в файловых хранилищах и последующего их восстановления.

=Частичная реализация=
Интерфейс Restorable частично реализует trait TRestorable, которые определяет одну из возможных техник восстановления объекта на основании строки - поиск и обработка лексем. Данная техника определяет следующий алгоритм восстановления объекта из строки:
# Поиск лексем - разделение строки-основания на части;
# Интерпретация лексем - определение семантики полученных частей;
# Преобразование лексем - изменение полученных частей (не обязательно);
# Восстановление объекта - создание объекта на основании полученных частей.

Основой в данной техники является лексема - минимальная, логически-значимая часть строки. TRestorable определяет общие механизмы поиска и обработки лексем, но не реализует логику преобразования этих лексем (п. 3) и восстановления из них объекта (п. 4), за это должен отвечать конкретный класс.

Для поиска лексем используется массив шаблонов регулярных выражений (маски), который должен возвращать метод getMasks данного trait. Часто в разных шаблонах верификации используются одни и те же лексемы, потому можно выделить их в отдельный ассоциативный массив, возвращаемый методом getPatterns, и использовать при формировании массива масок.

Поиск и интерпретацию лексем выполняет метод searchMask, который возвращает массив найденных лексем или false, если ни одна маска не подходит для восстановления объекта.

Метод searchMask используется в методе isReestablish для определения возможности восстановления объекта из строки.

Метод searchMask так же используется в методе reestablish, который переопределяет конкретный класс. Данный метод предоставляет лексемы для восстановления.

Процесс восстановления объекта из строки-основания с помощью TRestorable представлен на следующей схеме:

[[File:sequenceRestorable.png]]

Как видно класс использует метод searchMask для поиска лексем, а тот в свою очередь использует методы getMasks и getPatterns, переопределенные в конкретном классе. Ответственность за восстановление объекта из лексем остается за конкретным классом.

В качестве примера реализуем класс File из предыдущего примера с использованием TRestorable. Так же воспользуемся абстрактным классом RestorableAdapter, который реализует интерфейс Restorable с использованием TRestorable:

 class File extends RestorableAdapter implements Interpreter{
   ...

   public static function getMasks($driver = null){
     return ['((\/'.self::getPatterns()['fileName'].')+) ('.self::getPatterns()['fileName'].')']; // Шаблон верификации.
   }

   public static function getPatterns($driver = null){
     return ['fileName' => '[A-Za-z_]+']; // Именованная лексема, используемая в шаблоне верификации.
   }

   public static function reestablish($string, $driver = null){
     $tokens = parent::reestablish($string); // Вызов переопределенного метода в родительском классе для поиска лексем.
     return new self($tokens[1], $tokens[3]); // Формирование объекта из лексем.
   }
 }

Обратите внимание, метод getPatterns возвращает именованный массив частей регулярного выражения (именованные лексемы). Эти поисковые компоненты используются в шаблоне верификации метода getMasks, что предотвращает дублирование. Другими словами если в будущем будет необходимо изменить шаблон поиска имени файла или каталога в шаблоне верификации, достаточно изменить именованную лексему fileName в методе getPatterns.

Метод getMasks используется автоматически в методе reestablish родительского класса, что позволяет выделить искомые лексемы в соответствии с требованиями шаблона верификации. Стоит так же отметить, что вызов конструктора и передача ему лексем остается за методом reestablish дочернего класса.

Проверим как будет работать данный класс:

 $f = File::reestablish('/dirA/dirB/dirC file');
 echo $f->getLocation(); // /dirA/dirB/dirC
 echo $f->getName(); // file
