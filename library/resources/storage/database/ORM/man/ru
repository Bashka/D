=Терминология=
* Реляционное преобразование - создание SQL инструкции на базе персистентной сущности LongObject.

=Управление сущностями=
Для сохранения и восстановления персистентных объектов (дочерних классов LongObject), система Delphinum использует специальный класс, называемый EntityManager. Этот класс включает методы, позволяющие:
* insert - добавлять состояния объектов в базу;
* update - изменять состояния объектов в базе;
* delete - удалять состояния объектов из базы;
* recover - восстанавливать состояния объектов из базы;
* recoverFinding - восстанавливать состояния объектов из базы по известным значениям свойств;
* recoverGroupFinding - восстанавливать множество объектов из базы;
* recoverAssoc - восстанавливать состояния ассоциаций из базы.

Ниже приведен пример использования класса EntityManager:
 $em = EntityManager::getInstance();
 $u = new User();
 $u->setLogin('root');
 $u->setPassword(md5('root'));
 $guid = $em->insert($u); // Сохранение состояния объекта в базу данных.
 echo $guid; // Присвоеный объекту идентификатор.
 $u->setLogin('admin');
 $em->update($u); // Обновление состояния объекта.
 $u = User::getProxy($guid); // Получение ссылки на объект.
 $em->recover($u); // Востановление состояния объекта из ссылки.
 echo $u->getLogin(); // admin
 $em->delete($u); // Удаление состояния объекта из базы данных.
 $u = new User();
 $em->recoverFinding($u, [['login', '=', 'root']]); // Восстановление объекта через условие выборки. Все условия объединяются оператором AND. Ожидается один и только один объект, отвечающий данному условию.
 $em->recoverGroupFinding(User::getReflectionClass(), [['dateCreate', '>', '2000-01-01']]); // Восстановление нескольких объектов через условие выборки. Все условия объединяются оператором AND.

Как видно из примера, сохранение, обновление, восстановление и удаление состояний персистентных объектов выполняется с использованием класса EntityManager. Такой подход позволяет разделить логику управления персистентными объектами и сами эти объекты, в отличии от решений, в которых методы сохранения состояния объекта являются частью интерфейса самого объекта, как показано ниже:
 $u = new User();
 $u->setLogin('root');
 $u->setPassword(md5('root'));
 $u->save(); // Смешение логики объекта и механизов сохранения.

Следует так же отметить, что в условиях отбора методов recoverFinding и recoverGroupFinding используются имена свойств класса, а не имена полей таблиц базы данных.

==Выполнение транзакций==
Если необходимо выполнить несколько действий в контексте одной транзакции с помощью EntityManager, следует обратиться к используемому им DDO объекту, как показано ниже:
 $em = EntityManager::getInstance();
 $em->getDO()->beginTransaction(); // Начало транзакции.
 ... // Операции, относящиеся к транзакции.
 $em->getDO()->commit(); // Завершение транзакции.

При возникновении сбоя или выбросе исключения, используемый DDO объект актоматически отменит транзакцию.

==Фассадная природа класса==
Не следует забывать, что класс EntityManager является фассадом, облегчающим процесс взаимодействия с БД по средствам персистентных объектов. По сути все выполняемые данным классом действия могут быть выполнены программистом, что даст большую гибкость в реализации. Для понимания принципов работы класса EntityManager ниже приведен алгоритм обработки большинства запросов:
* Insert:
# Проверка на дублирование объекта в БД на основе свойств, помеченных аннотацией ORM\Unique;
# Генерация нового OID с помощью используемого OIDGenerator;
# Реляционное преобрезование объекта с помощью компонентов пакета mappers;
# Выполнение транзакции к БД;
# Установка OID объекту.
* Update:
# Проверка на дублирование объекта в БД на основе свойств, помеченных аннотацией ORM\Unique;
# Реляционное преобрезование объекта с помощью компонентов пакета mappers;
# Выполнение транзакции к БД.
* Delete:
# Реляционное преобрезование объекта с помощью компонентов пакета mappers;
# Удаление композита;
# Выполнение транзакции к БД.
* Recover:
# Реляционное преобрезование объекта с помощью компонентов пакета mappers;
# Выполнение запроса к БД;
# Проверка числа возвращенных записей на предмет множественности;
# Восстановление объекта.
* RecoverFinding и RecoverGroupFinding аналогичны Recover методу, с небольшими изменениями, касательно формирования SQL оператора и обработки ответа;
* RecoverAssoc:
# Выполнение запроса к БД используя установленный в ассоциации SQL оператор;
# Восстановление полученных объектов и добавление их в массив ассоциации.

Если вам необходимо гибко управлять процессом записи и удаления состояний персистентных объектов в базе данных, можно обойтись без EntityManager. Ниже представлен пример создания нового персистентного объекта и записи его в БД без проверки на дублирование:
 $u = new User;
 $OID = GUIDGenerator::getInstance()->generateOID(); // Генерация нового OID.
 $inserts = Insert::metamorphose($u, $OID); // Формирование SQL оператора Insert.
 DDOFabric::getInstance()->multiObjectQuery($insert); // Выполнение транзакции.
 $u->setOID($OID); // Установка идентификатора объекту.

Методы Insert, Update и Delete практически идентичны в своих реализациях, но для работы методов восстановления (Recover, RecoverFinding, RecoverGroupFinding и RecoverAssoc) необходим дополнительный метод, который будет правильно восстанавливать состояние персистентного объекта из массива данных, полученного от БД. Этим методом является setStateObject класса EntityManager, который принимает восстанавливаемый объект и его состояние в виде ассоциативного массива, и правильно восстанавливает его. Под правильным восстановлением состояния понимается восстановление объектных ссылок и множественных ассоциаций.

=Подготовка персистентных классов=
Для того, чтобы EntityManager мог подготовить SQL инструкцию из персистентного объекта, ему необходимы некоторые дополнительные данные, такие как: имя таблицы, в которой хранятся объекты этого класса; имя поля, хранящего первичный ключ (PK) объекта; маркеры уникальности; имена полей, хранящих значения конкретных свойств объекта и т.д. Для этих целей используются аннотации классов и свойств. Ниже приведены доступные аннотации:
* Аннотации класса:
** ORM\Table - имя таблицы, хранящей объекты данного класса;
** ORM\PK - имя поля таблицы, хранящего первичный ключ объекта (OID);
** Cache\Cache - маркер, определяющий классы, объекты которых должны кэшироваться.
* Аннотации свойств:
** ORM\ColumnName - имя поля таблицы, в которое должно быть записано значение данного свойства;
** ORM\Unique - маркер, определяющий поля, значения которых не должны повторяться в таблице, хранящей объект. Если данная аннотация определена для нескольких свойств объекта, то их совокупность не должна повторяться;
** ORM\Assoc - имя класса, объекты которого ассоциированы с данным объектом множественной связью;
** ORM\FK - имя свойства, которым ассоциированные объекты ссылаются на данный объект;
** ORM\Full - маркер, определяющий ассоциативное свойство, которое выполняет полную инициализацию связанных объектов (тип связи - один к одному, много к одному, один ко многим, много ко многому)
** ORM\Composition - маркер, определяющий композитную множественную ассоциацию (удаление объекта приводит к удалению композитов).

Ниже приведен пример класса, подготовленного с помощью аннотаций:
 /**
  * $ORM\Table Users - Объекты данного класса будут записываться в таблицу Users.
  * $ORM\PK OID - Идентификатор объектов данного класса (OID) будет записываться в поле OID таблицы.
  */
 class User extends LongObject{
   /**
    * @var string IP адрес пользователя.
    * $ORM\ColumnName ip - Значение данного свойства будет записано в поле ip таблицы.
    */
   protected $IP;

   /**
    * @var string Идентификатор сессии пользователя.
    * $ORM\ColumnName session
    */
   protected $session;

   /**
    * @var string Логин пользователя.
    * $ORM\ColumnName login
    * $ORM\Unique - Значение данного поля не должно повторяться в таблице.
    */
   protected $login;

   /**
    * @var string Пароль пользователя в виде хэш-суммы md5.
    * $ORM\ColumnName password
    */
   protected $password;

   ...
 }

==Обязательные аннотации==
Из перечисленных аннотаций, обязательными являются следующие: ORM\Table, ORM\PK, ORM\ColumnName. Без этих данных EntityManager не будет иметь достаточно данных для преобразования объекта в SQL инструкцию.

==Использование уникальных значений==
В случае, если необходимо обеспечить уникальность значений в том или ином свойстве, используется маркерная аннотация свойства ORM\Unique. Помеченные данной аннотацией свойства считаются уникальными, то есть их значения не должны повторяться в таблице. Особенностью данного маркера является то, что он суммирует значения помеченных свойств. То есть, если класс содержит более одного свойства с данным маркером, то в таблице не должны повторяться оба этих свойства.

Допустим нам необходимо, чтобы пользователь не мог создать себе учетную запись с логином, который уже присутствует в базе, для этого можно использовать аннотацию ORM\Unique на свойстве login как покажано в предыдущем примере.

Ниже приведен пример класса, использующего ORM\Unique для более чем одного свойства:
 /**
  * ...
  */
 class Rule extends LongObject{
   /**
    * ...
    * ORM\Unique
    */
   private $module;

   /**
    * ...
    * ORM\Unique
    */
   private $action;
 }

==Кэширование объектов==
Система Delphinum реализует сложный механизм кэширования персистентных объектов, позволяющий резко сократить время восстановления состояний персистентных объектов. Если необходимо, чтобы персистентный класс кэшировался, необходимо добавить ему анноатцию Cache\Cache.

==Единичные ассоциации==
Как записать связь типа "один-к-одному"? Все очень просто, достаточно установить в качестве значения свойства персистентный объект и сохранить состояние объекта:
 $u = new User();
 $u->setCity(City::getProxy('1'));
 $em->insert($u); // Объект класса User ссылается на объект класса City через свойство city.

Восстановление такой связи так же выполняется довольно легко:
 $u = User::getProxy('1');
 $em->recover($u);
 $c = $u->getCity(); // Получение ссылки на город.
 $em->recover($c);
 echo $c->getName(); // Получение имени города, в котором проживает пользователь.

Объект City, связанный с данным пользователем, перед использованием необходимо предварительно восстановить, так как это не делается по умолчанию, но можно заставить EntityManager делать это за вас с помощью аннотации ORM\Full:
 /**
  * ...
  * $ORM\Full
  */
 protected $city;

Теперь объект класса City будет восстановлен автоматически при восстановлении объекта User:
 $u = User::getProxy('1');
 $em->recover($u);
 $u->getCity()->getName(); // Получение имени города, в котором проживает пользователь.

В случае, если необходимо получить всех пользователей, проживающих в указанном городе, следует использовать объект, а не его идентификатор:
 $em->recoverGroupFinding(User::getReflectionClass(), [['city', '=', City::getProxy('1')]]);

==Аннотирование множественных ассоциаций==
Предположим есть два класса: пользователь (User) и группы доступа (Role), в которые он входит - как реализовать связь типа "много-ко-многим" для объектов данных классов, чтобы можно было хранить информацию о том, какой пользователь в какие группы входит?

Для начал приведем листинги этих классов:
 /**
  * $ORM\Table Users
  * $ORM\PK OID
  */
 class User extends LongObject{
   /**
    * $ORM\ColumnName login
    * $ORM\Unique
    */
   protected $login;

   /**
    * $ORM\ColumnName password
    */
   protected $password;

   ...
 }

 /**
  * $ORM\Table Roles
  * $ORM\PK OID
  */
 class Role extends LongObject{
   /**
    * $ORM\ColumnName name
    * $ORM\Unique
    */
   protected $name;

   ...
 }

Очевидно, что для реализации множественной связи между этими двумя классами необходим класс вида:
 class UserRole extends LongObject{
   protected $user;

   protected $role;

   ...
 }

Свойство user данного класса хранит ссылку на конкретного пользователя, а свойство role ссылку на группу доступа, в которую он входит. Но как же объяснить EntityManager что это именно ассоциация? Можно использовать групповое восстановление сущностей (recoverGroupFinding) для восстановления связи:
 $em = EntityManager::getInstance();
 $u = User::getProxy('1'); // Получение ссылки на объект.
 $em->recoverGroupFinding(UserRole::getReflectionClass(), [['user', '=', $u]]);

Это, конечно, позволит восстановить множественную ассоциацию, но есть способ проще. Для этого достаточно указать несколько дополнительных аннотаций классу User:
 /**
   * $ORM\Table Users
   * $ORM\PK OID
   */
 class User extends LongObject{
   /**
    * $ORM\ColumnName login
    * $ORM\Unique
    */
   protected $login;

   /**
    * $ORM\ColumnName password
    */
   protected $password;

   /**
    * $ORM\Assoc UserRole - имя класса, который связан с данным классом множественной ассоциацией.
    * $ORM\FK user - имя свойства класса, через которое он ссылается на объекты данного класса.
    */
   protected $roles;

   ...
 }

Теперь множественная ассоциация будет формироваться автоматически при восстановление объектов класса User:
 $em = EntityManager::getInstance();
 $u = User::getProxy('1'); // Получение ссылки на объект.
 $em->recover($u);
 $roles = $u->getRoles();
 $em->recoverAssoc($roles);
 foreach($roles as $role){
   echo $role->getRole()->getName(); // Получение имен групп доступа, в которые входит пользователь.
 }

Может показаться, что такая запись более грамоздка по сравнению с предыдущей, но на самом деле это не так. Такой подход более очевиден, так как определяет множественную ассоциацию как часть объекта (свойство объекта), еще больше абстрагируя от реляционной структуры базы данных. Использование метода recoverAssoc здесь обусловлено тем, что множественная ассоциация хоть и создается при восстановлении объекта, но не инициализируется, для предотвращения запроса слишком больших порций данных. Если же вы хотите, чтобы множественная ассоциация инициализировалась сразу, используется аннотация ORM\Full:
 /**
  * $ORM\Assoc UserRole
  * $ORM\FK user
  * $ORM\Full
  */
 protected $roles;

После этого восстановить связь можно так:
 $em = EntityManager::getInstance();
 $u = User::getProxy('1'); // Получение ссылки на объект.
 $em->recover($u);
 foreach($u->getRoles() as $role){
   echo $role->getRole()->getName(); // Получение имен групп доступа, в которые входит пользователь.
 }

Вы наверно уже обратили внимание на строку:
 echo $role->getRole()->getName();
и задались вопросом, почему сначала выполняется вызов метода getRole? Дело в том, что для связи используется класс UserRole, который хранит ссылку как на пользователя, так и на группу доступа, в которую он входит. Следовательно ассоциация формируется из объектов этого класса, а это значит что для начала нужно получить объект класса Role с помощью вызова метода getRole, а уже потом получить имя группы доступа.
==Композитная ассоциация==
Часто необходимо реализовать композитную связь, то есть такую связь, при которой удаление объекта приводит к удалению всех связанных с ним объектов. Такое можно наблюдать при удалении объекта User. После этого действия должны быть удалены все связи UserRole, чтобы избежать "повисших связей". Для автоматизации этого процесса используется аннотация ORM\Composition. Помеченные ею свойства-аннотации считаются композитными:
 /**
  * $ORM\Assoc Role
  * $ORM\FK user
  * $ORM\Full
  * $ORM\Composition
  */
 protected $roles;

При такой реализации класса User, удаление его экземпляра привидет к удалению всех объектов UserRole, которые ссылаются на него через свойство user.